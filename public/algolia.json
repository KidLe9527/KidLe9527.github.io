[
  {
    "objectID": "19885dfd0cbba3b5577b6cb3287769dceae3bf69",
    "permalink": "//localhost:1313/post/linux/",
    "title": "linux学习过程心得体会","content": "\rLINUX 学习笔记\rLinux 基础命令\rLinux命令基础格式\rcommand [-options] [parameter] command：命令本身 -options：[可选，非必填]，命令的一些选项，可以通过选项控制命令的行为细节 parameter：[可选，非必填]，命令的参数，多数用于命令的指向目标 ls命令（查看目录下文件）\rls 命令的参数作用，可以指定要查看的文件夹（目录）的内容，如果不给定参数，默认当前工作目录的内容 ls 的命令选项： -a：可以展示出隐藏的内容 以.开头的文件或文件夹默认被隐藏，需要-a才能显示出来 -l：以列表的形式展示内容，并展示更多细节 -h：需要和-l 选项搭配使用，以更加人性化的方式显示文件的大小单位 命令的选项是可以组合使用的，比如：ls -lah = ls -a -l -h cd 和 pwd （切换显示目录）\rcd命令的作用\ncd命令来自英文：Change Directory.\ncd命令可以切换当前工作目录,语法是：\n没有选项，只有参数，表示目标路径 使用参数，切换工作目录到指定路径（默认切换到当前用户的HOME） cd [linux路径]\tpwd 命令的作用 pwd命令来自英文：Print Work Directory pwd命令，没有选项，没有参数，直接使用即可 作用：输出当前所在的工作目录 相对、绝对路径和特殊路径符\r绝对路径：以根目录作为起点，路径必须要以 / 开头 相对路径：以当前目录作为起点，描述路径的方式，路径不需要以 / 开头 特殊路径符 .：表示当前目录，egcd ./Desktop 表示切换到当前目录下的Desktop 目录内 ..：表示上一级目录，eg cd ../.. 表示切换到上二级目录 ~：表示HOME目录， eg cd ~/Desktop = cd ./Desktop 切换到切换到HOME下的Desktop目录 mkdir命令(创建目录)\rmkdir命令来自英文：Make Directory mkdir命令可以创建新的目录和文件夹 语法：mkdir [-p] linux路径 参数必填，表示linux路径，即要创建的文件夹路径 -p 选项可选，表示自动创建不存在的父目录，适用于创建连续多层级的目录 注意：创建文件夹需要修改权限，初学请确保在HOME目录下操作 tips: …","date": "2025-08-17 00:00:00",
    "updated": "2025-08-17 00:00:00"
  }, 
  {
    "objectID": "70c2dda49bc85ce5c167b3e6598922719d25ea0c",
    "permalink": "//localhost:1313/post/cppnote/",
    "title": "CPP学习过程心得体会","content": "\r学习C++新特性\rC++11\rsto类函数（字符串转数字）\rstd::stoi (字符串转整数)\u0026amp;mdash;\u0026amp;mdash;\u0026amp;mdash;\u0026amp;mdash;\u0026amp;mdash;\u0026amp;gt;\u0026amp;ldquo;string to integer\u0026amp;quot;​​ std::stol (字符串转长整数) std::stoll (字符串转长长整数) std::stof (字符串转浮点数) std::stod (字符串转双精度浮点数) #include \u0026amp;lt;string\u0026amp;gt; std::string str = \u0026amp;#34;123\u0026amp;#34;; int num = std::stoi(str); // num = 123 对于简单转换，使用 std::stoi/std::stod 系列函数 int stoi(const std::string\u0026amp;amp; str, size_t* pos = 0, int base = 10); // 其他函数参数类似 参数说明： str：要转换的字符串 pos：可选参数，存储第一个未转换字符的位置 base：可选参数，指定数字的基数（2-36） 其他用法 指定进制转换 std::string hex_str = \u0026amp;#34;FF\u0026amp;#34;; int hex_num = std::stoi(hex_str, nullptr, 16); // 255 (十六进制) std::string bin_str = \u0026amp;#34;1010\u0026amp;#34;; int bin_num = std::stoi(bin_str, nullptr, 2); // 10 (二进制) 获取未转换部分位置 std::string str = \u0026amp;#34;123abc\u0026amp;#34;; size_t pos; int num = std::stoi(str, \u0026amp;amp;pos); // num=123, pos=3 istringstream(流输入)\rstd::istringstream是 C++ 标准库中的一个类，属于 字符串流（String Streams） 的一部分，定义在 \u0026amp;lt;sstream\u0026amp;gt;头文件中。它允许将字符串（std::string）当作输入流（类似 std::cin）来处理，方便进行格式化的数据提取和解析。 std::string text = \u0026amp;#34;C++ is …","date": "2025-08-10 22:01:00",
    "updated": "2025-08-10 22:02:00"
  }, 
  {
    "objectID": "cbedc6323655123a57d05e382281bbdb427ee1f7",
    "permalink": "//localhost:1313/post/mysql/",
    "title": "MySQL学习过程心得体会","content": "\rMySQL学习记录\rMySQL学习笔记\r针对MySQL刷题过程中遇到的一些问题及解决办法\r派生表必须要有别名\r1. Every derived table must have its own alias 这个错误消息的意思是\u0026amp;quot;每个派生表必须有自己的别名\u0026amp;quot;，这是 MySQL 在执行 SQL 查询时常见的语法错误。 -- 错误的写法：子查询没有别名 SELECT * FROM (SELECT * FROM employees); -- 正确的写法：为子查询指定别名 SELECT * FROM (SELECT * FROM employees) AS emp; 只有表才能取别名\r2. You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \u0026amp;#39;x ) y\u0026amp;#39; at line 9 这个错误是因为你在子查询的末尾添加了不必要的别名 x ，而 MySQL 不允许在这种位置使用它们。\n错误代码： SELECT MAX(salary) SecondHighestSalary FROM ( SELECT salary FROM Employee WHERE salary \u0026amp;lt; ( SELECT max(salary) from Employee ) x -- 就是这里没有引用不需要添加别名 ) y; \u0026amp;ndash;\u0026amp;gt; 在 MySQL 中，子查询的别名通常用于 FROM 子句中的表引用，但你的查询没有使用它们，所以 MySQL 会报错。\n聚合函数的使用位置\r聚合函数只能用于 SELECT列表或HAVING子句中，不能直接用于WHERE子句或GROUP BY子句。如果需要基于聚合结果进行筛选，应该使用HAVING而不是WHERE ！！ 小难的题目\r3642. 查找有两极分化观点的书籍 - 力扣（LeetCode） 别人写的代码 # Write your MySQL query statement below select b.book_id, title, author, genre, pages, rating_spread, …","date": "2025-08-10 22:01:00",
    "updated": "2025-08-10 22:02:00"
  }, 
  {
    "objectID": "03e5f536384ab350725cd7b956834b3100e85ac0",
    "permalink": "//localhost:1313/post/algorithm/",
    "title": "算法学习过程心得体会","content": "\rKMP算法\r下标从零开始 //这个 KMP 函数的返回值是模式串 t 在主串 s 中第一次出现的起始位置（从 0 开始计数） int kmp(const string\u0026amp; s, const string\u0026amp; t){ int s_length = s.size(), t_length = t.size(); if (t_length == 0) return 0; if (s_length \u0026lt; t_length) return -1; //求next数组(从下标0开始) vector\u0026lt;int\u0026gt; next(t_length + 1);//大小 + 1防止堆和缓冲区溢出 //next[t_length]的值是t字符串的最大前后缀公共长度 next[0] = -1; int i = 0, j = -1;//i是当前正在计算next值的位置；j是前缀指针，当前已经匹配的长度 while(i \u0026lt; t_length){ if(j == -1 || t[i] == t[j]){//j = -1表示没有匹配的前缀 next[++i] = ++j; }else{ j = next[j]; } } //KMP匹配，求t字符串在s字符串中出现的第一次位置 i = 0, j = 0;//i是主串指针，j是匹配串指针 while(i \u0026lt; s_length \u0026amp;\u0026amp; j \u0026lt; t_length){ if(j == -1 || s[i] == t[j]){ ++i, ++j; }else{ j = next[j]; } } return j == t_length ? i - j : -1; } }; 这个 KMP 函数的返回值是模式串 t 在主串 s 中第一次出现的起始位置（从 0 开始计数）。具体来说\n如果 t 是空字符串（t_length == 0），返回 0，因为空字符串被认为是任何字符串的子串，且出现在位置 0。 如果 s 的长度小于 t 的长度（s_length \u0026lt; t_length），返回 -1，表示 t 不可能是 s 的子串。 如果 t 在 s 中找到匹配，返回匹配的起始位置（即 i - j，其中 i 是 s 中匹配结束的位置，j 是 t 的长度）。 如果 t 不在 s 中，返回 -1。 例如：\nkmp(\u0026ldquo;hello\u0026rdquo;, \u0026ldquo;ll\u0026rdquo;) 返回 2 kmp(\u0026ldquo;aaaaa\u0026rdquo;, \u0026ldquo;bba\u0026rdquo;) 返回 -1 kmp(\u0026ldquo;any\u0026rdquo;, \u0026ldquo;\u0026rdquo;) 返回 0 注意：这个实现是从 0 开始计数的，与 C++ 的 std::string::find() 的返回值语义相同。\n下标从1开始的求next数组的kmp算法 int GetNext(char ch[], int length, int next[]){ next[1] = 0; int i = 1, j = 0; while(i \u0026lt;= length){ if(j==0 || ch[i] == ch[j]){ next[++i] = ++j; }else{ j = next[j]; } } } 459. 重复的子字符串 - 力扣（LeetCode）\n回溯问题\r17. 电话号码的字母组合 - 力扣（LeetCode）\n代码如下： class Solution { private: vector\u0026lt;string\u0026gt; dic = {\u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;abc\u0026#34;, \u0026#34;def\u0026#34;, \u0026#34;ghi\u0026#34;, \u0026#34;jkl\u0026#34;, \u0026#34;mno\u0026#34;, \u0026#34;pqrs\u0026#34;, \u0026#34;tuv\u0026#34;, \u0026#34;wxyz\u0026#34;}; public: vector\u0026lt;string\u0026gt; letterCombinations(string digits) { int n = digits.size(); if(n == 0) return {}; vector\u0026lt;string\u0026gt; ans; string path; auto dfs = [\u0026amp;](this auto\u0026amp;\u0026amp; dfs, int i)-\u0026gt;void{ if(i == n){ ans.emplace_back(path); return; } int idx = digits[i] - \u0026#39;0\u0026#39;; for(int j = 0; j \u0026lt; dic[idx].size(); ++j){ path += dic[idx][j]; dfs(i + 1); path.pop_back();// 回溯，移除最后一个字母！ 必须要回溯！ } }; dfs(0);//回溯的入口！ return ans; } }; 这里path.pop_back()用于递归后回溯的恢复数据，如果没有这一步path的路径会随着递归深入一直变长~ ","date": "2025-08-10 22:01:00",
    "updated": "2025-08-10 22:02:00"
  }, 
  {
    "objectID": "80cfd4953eaa97ec85954654bf18c4e6643d16c4",
    "permalink": "//localhost:1313/post/firstblog/",
    "title": "真正意义上的第一篇博客","content": "\r正式开始小白乐的博客生涯\r先记录一下搭建博客的过程！\r过程真的很繁琐，网上的视频教程不是很详细，虽然但是，仅凭我一个人真的搞不定，所以在淘宝上花rmb请人帮我实操了，该说不说，这位大哥确实很顶，态度非常之诚恳，技术相当之过硬，话术非常之高端（听起来很专业~），对于我的每一个请求，都相当之耐心，就我觉得太麻烦不好实现的功能，这位哥还是很坚持的帮助我实现‘愿望’，虽然但是，可能不是很完美的还原功能，但是大哥的心意和精神，相当的值得肯定，牛逼！佬！然后就是一些细枝末节的外观美化和小tips，这些就交给小白乐自己弄吧，确实不好意思再麻烦大哥了，总共就给人家100软妹币，不仅给我讲解操作，还直接远程操控我电脑帮我弄，还给我解决问题，前前后后大概四五个小时，他人真的我哭死。感觉对面也就是大我五六岁（最多）的样子，但是看看人家，再看看我，感觉我是个飞舞，啥都不会~还是计算机专业的学生，这\u0026amp;hellip;\u0026amp;hellip; 但是，还是搞定了，不管过程怎么样，结果是好的就行，嘻嘻！ 再记录一下搭建博客中遇到的一些问题\r首先就是心仪的这个二次元的主题跟视频里的文件结构不一样，所以憨憨乐找不到对应的文件（这就是不看人家readme的下场），所以迫不得已才寻求help，但是都是小问题\n本次搭建博客是用到hugo + github实现的，本来想的是用云服务器那种搭法，但是首先云服务器和域名的租用都是要花银子的，本身自己搭建博客的目的就是记笔记、写日记之类的，所以并不是很需要这些东西，以后有需求再说吧，虽然感觉那种动态博客的搭建要简单一点，而且功能还很不错，但是，目前就先这样吧，先积累下经验，毕竟确实在这方面我跟白纸没什么区别\n搭建的具体过程参考主题的readme文件吧，人家写的确实很好，但是为什么不写的更详细一点，废吉乐还是看不懂（主题创建者搞这个玩意的时候应该是大四左右了，好厉害，感觉自己大四了还是会一事无成~~555）继续努力吧，没什么其他的办法，慢慢来\n其实搭建的过程并不复杂，真正考验我的是美化博客的过程~~记录一下本来准备好让大哥帮我弄好的地方\n头像下方的链接（这个好像必须要代码编辑器才行，一开始自己在typora上修改没用，因为typora有隐藏字符，废物！换成vscode改好了，不难）\n写文章的开头怎么弄,这个大哥不怎么弄明白，但是哈吉乐已经会了就是在开头三 …","date": "2025-08-09 11:32:00",
    "updated": "2025-08-09 19:13:00"
  }, 
  {
    "objectID": "2b7a67be88c5c366cb505d430a3488bc39d97abd",
    "permalink": "//localhost:1313/post/linux%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/",
    "title": "linux系统软件安装说明文档","content": "\r实战章节：在Linux上部署各类软件\r前言\r为什么学习各类软件在Linux上的部署\r在前面，我们学习了许多的Linux命令和高级技巧，这些知识点比较零散，同学们跟随着课程的内容进行练习虽然可以基础掌握这些命令和技巧的使用，但是并没有一些具体的实操能够串联起来这些知识点。\n所以，现在我们设计了各类软件在Linux上部署安装的实战章节，可以让同学们：\n对前面学习的各类操作命令进行复习和练习，从而深度掌握它们 本章节中演示部署的软件，包含了IT行业各类岗位中所必须使用的，如：Java后台、大数据开发、运维开发、测试、AI等。无论学习Linux后从事什么岗位，这些内容都会给你带来帮助 对于零基础学员，实战课程中所讲解的软件大概率多数大家并不了解。\n所以，课程仅涉及到安装部署，不对软件的使用做详细说明。\n同学们在这个过程中，可能会遇到各种各样的错误，不要怕，解决它，将会给你带来极大的提升。\n学习目标\r对于本部分的内容学习，我们设计两个目标：\n对于零基础或未从业的学员，不要求深入理解所安装部署的软件是什么，仅仅能够跟随课程成功的将其部署安装并运行成功即可\n在这个过程中，主要锻炼大家对Linux操作系统的熟练度，此乃零基础未从业学员的第一学习目标\n对于有基础或已从业的学员，本章节讲解的软件涵盖了大多数IT从业者所能接触到的，特别是大数据开发、后端开发两个主流方向，可以作为参考资料，以便在工作中有所帮助。\n本章节内的各类软件安装，==不强制要求全部学习==\n零基础学员，建议全部学习，作为前面学习内容的总结和实战 IT从业者、有经验学员，可以按需选择，选择工作中需要用到的进行学习 章节内包含的软件并非100%涵盖了IT开发领域中所需要的内容。\n如果您对某些软件的安装有强烈需求，且课程中没有提供教程，可以私信B站：\u0026amp;ldquo;黑马大数据曹老师\u0026amp;rdquo;，老师会酌情根据时间安排补充上去哦。\n为什么不使用PPT而是使用文档进行授课\r从现在开始，将要进入到Linux的实操阶段，在这个阶段我们将会涉及到非常多的软件部署等操作，涉及到：\n各类命令的使用 各种过程的结果 复杂的流程步骤 等 这些信息的展示，并不适合于使用PPT作为载体进行授课，所以从现在开始我们将使用操作文档的模式为大家进行讲解。\n使用文档模式还有一个好处，除了学习视频以外，拿到课程中使用的操作文档，同样可以作为重要的参考 …","date": "2022-09-17 00:00:00",
    "updated": "2022-09-17 00:00:00"
  }, 
  {
    "objectID": "f7515073354bf70d1a3b6ac5836c4961a443b8da",
    "permalink": "//localhost:1313/post/pythonnote/",
    "title": "","content": "\r快速过一遍python的知识~\r基本语法\r解释型：Python是边解释边执行的，Python解释器会将源代码转换为中间字节码形式，然后将其解释为机器语言并执行\npython 3采用双字节Unicode编码，包含亚洲文字编码，如中文、日文、韩文等字符。\nPython中标识符的命名规则如下。 1 区分大小写：Myname与myname是两个不同的标识符。 2 首字符可以是下画线（_）或字母，但不能是数字。 3 除首字符外的其他字符必须是下画线、字母和数字。 4 关键字不能作为标识符。 5 不要使用Python的内置函数作为自己的标识符\npython只有33个关键字，其中False、None、True的首字母大写，其他关键字全都是小写\npython语句结束时可以加分号，但不符合python编程规范\na = b = c = 10，支持链式赋值\n代码注释：# 这是一个注释\n在Python中一个模块就是一个文件，模块是保存代码的最小单位，在模块中可以声明变量、函数、属性和类等Python代码元素。\n1. import m2 # m2是一个模块，通过这种方式导入模块m2中的所有代码元素，在访问时需要加前缀m2. eg：print(m2.x) 2. from m2 import x # 从m2中导入x变量，在访问时不需要加前缀m2. 3.from m2 import x as x2 # 类似2，只是可能由于变量名冲突，起了个别名 数据类型\r​\tpython内置了主要6种数据类型：数字、字符串、列表、元组、集合和字典，其中：\n列表、元组、集合和字典可以容纳多项数据 数字类型\r​\t数字类型主要有4种：整数类型、浮点类型、复数类型和布尔类型（布尔类型事实上是整数类型的一种）\n二进制表示方法，以阿拉伯数字0和英文字母b作为前缀（都不区分大小写）: 0b11100 -\u0026amp;gt; 28 八进制表示方法，以阿拉伯数字0和英文字母o作为前缀: 0o34 -\u0026amp;gt; 28 十六进制表示方法，以阿拉伯数字0和字母x作为前缀：0x1c -\u0026amp;gt; 28 浮点类型主要用于存储小数数值，python的浮点类型为float，只支持双精度浮点类型 3.36e2 = 336.0; .56e-2 = 0.0056 ---\u0026amp;gt;科学表示法，会使用e/E表示10的指数 复数类型：复数在数学中被表示为a + bi, 其 …","date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }]