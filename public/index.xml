<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <link>//localhost:1313/algolia.json</link>
    <description>Recent content from </description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    
    <managingEditor>2267593025@qq.com (the_last_kid)</managingEditor>
    <webMaster>2267593025@qq.com (the_last_kid)</webMaster>
    
    <copyright>本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！</copyright>
    
    <lastBuildDate>Sun, 10 Aug 2025 22:02:00 -0800</lastBuildDate>
    
    
    <atom:link href="//localhost:1313/index.xml" rel="self" type="application/rss&#43;xml" />
    

    
    

    <item>
      <title>算法学习过程心得体会</title>
      <link>//localhost:1313/post/algorithm/</link>
      <pubDate>Sun, 10 Aug 2025 22:01:00 -0800</pubDate>
      <author>2267593025@qq.com (the_last_kid)</author>
      <guid>//localhost:1313/post/algorithm/</guid>
      <description>
        <![CDATA[<h1>算法学习过程心得体会</h1><p>作者：the_last_kid（2267593025@qq.com）</p>
        
          <h2 id="kmp算法">
<a class="header-anchor" href="#kmp%e7%ae%97%e6%b3%95"></a>
KMP算法
</h2><ol>
<li>下标从零开始</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">//</span><span class="err">这个</span> <span class="n">KMP</span> <span class="err">函数的返回值是模式串</span> <span class="n">t</span> <span class="err">在主串</span> <span class="n">s</span> <span class="err">中第一次出现的起始位置（从</span> <span class="mi">0</span> <span class="err">开始计数）</span>
</span></span><span class="line"><span class="cl"><span class="ne">int</span> <span class="n">kmp</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="ne">int</span> <span class="n">s_length</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">t_length</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">t_length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">s_length</span> <span class="o">&lt;</span> <span class="n">t_length</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="o">//</span><span class="err">求</span><span class="n">next数组</span><span class="p">(</span><span class="err">从下标</span><span class="mi">0</span><span class="err">开始</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">vector</span><span class="o">&lt;</span><span class="ne">int</span><span class="o">&gt;</span> <span class="n">next</span><span class="p">(</span><span class="n">t_length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span><span class="o">//</span><span class="err">大小</span> <span class="o">+</span> <span class="mi">1</span><span class="err">防止堆和缓冲区溢出</span>
</span></span><span class="line"><span class="cl">        <span class="o">//</span><span class="n">next</span><span class="p">[</span><span class="n">t_length</span><span class="p">]</span><span class="err">的值是</span><span class="n">t字符串的最大前后缀公共长度</span>
</span></span><span class="line"><span class="cl">        <span class="n">next</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="ne">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="o">//</span><span class="n">i是当前正在计算next值的位置</span><span class="err">；</span><span class="n">j是前缀指针</span><span class="err">，当前已经匹配的长度</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">t_length</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">t</span><span class="p">[</span><span class="n">j</span><span class="p">]){</span><span class="o">//</span><span class="n">j</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="err">表示没有匹配的前缀</span>
</span></span><span class="line"><span class="cl">                <span class="n">next</span><span class="p">[</span><span class="o">++</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">++</span><span class="n">j</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">j</span> <span class="o">=</span> <span class="n">next</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="o">//</span><span class="n">KMP匹配</span><span class="err">，求</span><span class="n">t字符串在s字符串中出现的第一次位置</span>
</span></span><span class="line"><span class="cl">        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="o">//</span><span class="n">i是主串指针</span><span class="err">，</span><span class="n">j是匹配串指针</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">s_length</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">t_length</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">t</span><span class="p">[</span><span class="n">j</span><span class="p">]){</span>
</span></span><span class="line"><span class="cl">                <span class="o">++</span><span class="n">i</span><span class="p">,</span> <span class="o">++</span><span class="n">j</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">j</span> <span class="o">=</span> <span class="n">next</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">j</span> <span class="o">==</span> <span class="n">t_length</span> <span class="err">?</span> <span class="n">i</span> <span class="o">-</span> <span class="n">j</span> <span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><ul>
<li>
<p>这个 KMP 函数的返回值是模式串 t 在主串 s 中第一次出现的起始位置（从 0 开始计数）。具体来说</p>
        
        <hr><p>本文2025-08-10首发于<a href='//localhost:1313/'></a>，最后修改于2025-08-10</p>]]>
      </description>
      
        <category>笔记</category>
      
    </item>
    
    

    <item>
      <title>MySQL学习过程心得体会</title>
      <link>//localhost:1313/post/mysql/</link>
      <pubDate>Sun, 10 Aug 2025 22:01:00 -0800</pubDate>
      <author>2267593025@qq.com (the_last_kid)</author>
      <guid>//localhost:1313/post/mysql/</guid>
      <description>
        <![CDATA[<h1>MySQL学习过程心得体会</h1><p>作者：the_last_kid（2267593025@qq.com）</p>
        
          <h1 id="mysql学习笔记">
<a class="header-anchor" href="#mysql%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"></a>
MySQL学习笔记
</h1><h2 id="针对mysql刷题过程中遇到的一些问题及解决办法">
<a class="header-anchor" href="#%e9%92%88%e5%af%b9mysql%e5%88%b7%e9%a2%98%e8%bf%87%e7%a8%8b%e4%b8%ad%e9%81%87%e5%88%b0%e7%9a%84%e4%b8%80%e4%ba%9b%e9%97%ae%e9%a2%98%e5%8f%8a%e8%a7%a3%e5%86%b3%e5%8a%9e%e6%b3%95"></a>
针对MySQL刷题过程中遇到的一些问题及解决办法
</h2><h3 id="派生表必须要有别名">
<a class="header-anchor" href="#%e6%b4%be%e7%94%9f%e8%a1%a8%e5%bf%85%e9%a1%bb%e8%a6%81%e6%9c%89%e5%88%ab%e5%90%8d"></a>
派生表必须要有别名
</h3><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">1. Every derived table must have its own alias
</span></span></code></pre></div><ul>
<li>这个错误消息的意思是&quot;每个<code>派生表</code>必须有自己的别名&quot;，这是 MySQL 在执行 SQL 查询时常见的语法错误。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">-- 错误的写法：子查询没有别名
</span></span><span class="line"><span class="cl">SELECT * FROM (SELECT * FROM employees);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">-- 正确的写法：为子查询指定别名
</span></span><span class="line"><span class="cl">SELECT * FROM (SELECT * FROM employees) AS emp;
</span></span></code></pre></div><hr>
<h3 id="只有表才能取别名">
<a class="header-anchor" href="#%e5%8f%aa%e6%9c%89%e8%a1%a8%e6%89%8d%e8%83%bd%e5%8f%96%e5%88%ab%e5%90%8d"></a>
只有<code>表</code>才能取别名
</h3><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">2. You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;x
</span></span><span class="line"><span class="cl">) y&#39; at line 9
</span></span></code></pre></div><p>这个错误是因为你在子查询的末尾添加了不必要的别名 <code> x</code> ，而 MySQL 不允许在这种位置使用它们。</p>
        
        <hr><p>本文2025-08-10首发于<a href='//localhost:1313/'></a>，最后修改于2025-08-10</p>]]>
      </description>
      
        <category>笔记</category>
      
    </item>
    
    

    <item>
      <title>CPP学习过程心得体会</title>
      <link>//localhost:1313/post/cppnote/</link>
      <pubDate>Sun, 10 Aug 2025 22:01:00 -0800</pubDate>
      <author>2267593025@qq.com (the_last_kid)</author>
      <guid>//localhost:1313/post/cppnote/</guid>
      <description>
        <![CDATA[<h1>CPP学习过程心得体会</h1><p>作者：the_last_kid（2267593025@qq.com）</p>
        
          <h1 id="学习c新特性">
<a class="header-anchor" href="#%e5%ad%a6%e4%b9%a0c%e6%96%b0%e7%89%b9%e6%80%a7"></a>
学习C++新特性
</h1><h2 id="c11">
<a class="header-anchor" href="#c11"></a>
C++11
</h2><h3 id="sto类函数字符串转数字">
<a class="header-anchor" href="#sto%e7%b1%bb%e5%87%bd%e6%95%b0%e5%ad%97%e7%ac%a6%e4%b8%b2%e8%bd%ac%e6%95%b0%e5%ad%97"></a>
sto类函数（字符串转数字）
</h3><ul>
<li>std::stoi (字符串转整数)&mdash;&mdash;&mdash;&mdash;&mdash;&gt;&ldquo;string to integer&quot;​​</li>
<li>std::stol (字符串转长整数)</li>
<li>std::stoll (字符串转长长整数)</li>
<li>std::stof (字符串转浮点数)</li>
<li>std::stod (字符串转双精度浮点数)</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span> <span class="o">=</span> <span class="s">&#34;123&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">stoi</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>  <span class="c1">// num = 123
</span></span></span></code></pre></div><ul>
<li>对于简单转换，使用 std::stoi/std::stod 系列函数</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="ne">int</span> <span class="n">stoi</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="nb">str</span><span class="p">,</span> <span class="n">size_t</span><span class="o">*</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="ne">int</span> <span class="n">base</span> <span class="o">=</span> <span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="o">//</span> <span class="err">其他函数参数类似</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">参数说明：</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">str</span><span class="err">：要转换的字符串</span>
</span></span><span class="line"><span class="cl"><span class="n">pos</span><span class="err">：可选参数，存储第一个未转换字符的位置</span>
</span></span><span class="line"><span class="cl"><span class="n">base</span><span class="err">：可选参数，指定数字的基数（</span><span class="mi">2</span><span class="o">-</span><span class="mi">36</span><span class="err">）</span>
</span></span></code></pre></div><ul>
<li>其他用法</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">指定进制转换
</span></span><span class="line"><span class="cl">std::string hex_str = &#34;FF&#34;;
</span></span><span class="line"><span class="cl">int hex_num = std::stoi(hex_str, nullptr, 16);  // 255 (十六进制)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">std::string bin_str = &#34;1010&#34;;
</span></span><span class="line"><span class="cl">int bin_num = std::stoi(bin_str, nullptr, 2);   // 10 (二进制)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">获取未转换部分位置
</span></span><span class="line"><span class="cl">std::string str = &#34;123abc&#34;;
</span></span><span class="line"><span class="cl">size_t pos;
</span></span><span class="line"><span class="cl">int num = std::stoi(str, &amp;pos);  // num=123, pos=3
</span></span></code></pre></div><h3 id="istringstream流输入">
<a class="header-anchor" href="#istringstream%e6%b5%81%e8%be%93%e5%85%a5"></a>
istringstream(流输入)
</h3><ul>
<li><code>std::istringstream</code>是 C++ 标准库中的一个类，属于 <strong>字符串流（String Streams）</strong> 的一部分，定义在 <code>&lt;sstream&gt;</code>头文件中。它允许将字符串（<code>std::string</code>）当作输入流（类似 <code>std::cin</code>）来处理，方便进行格式化的数据提取和解析。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">std::string text = &#34;C++ is awesome&#34;;
</span></span><span class="line"><span class="cl">std::istringstream iss(text);
</span></span><span class="line"><span class="cl">std::string word;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">while (iss &gt;&gt; word) {  // 按空格分割
</span></span><span class="line"><span class="cl">    std::cout &lt;&lt; word &lt;&lt; std::endl;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><h2 id="c17">
<a class="header-anchor" href="#c17"></a>
C++17
</h2><h3 id="reduce函数序列元素归约">
<a class="header-anchor" href="#reduce%e5%87%bd%e6%95%b0%e5%ba%8f%e5%88%97%e5%85%83%e7%b4%a0%e5%bd%92%e7%ba%a6"></a>
reduce函数（序列元素归约）
</h3><ol>
<li>reduce函数是 C++17 引入的一个算法，用于对序列中的元素进行归约（reduction）操作，类似于 accumulate 但具有并行计算的潜力</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="err">语法</span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;numeric&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">st</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span></code></pre></div><ol start="2">
<li>默认行为</li>
</ol>
<ul>
<li>当不提供初始值和操作时：
<ol>
<li>默认使用 std::plus&lt;&gt;() 作为二元操作（即加法）</li>
<li>默认初始值为 typename iterator_traits<!-- raw HTML omitted -->::value_type{}（即该类型的默认构造值）</li>
</ol>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">*int/float 等：初始值为 0，执行加法
</span></span><span class="line"><span class="cl">vector&lt;int&gt; v{1, 2, 3};
</span></span><span class="line"><span class="cl">int sum = reduce(v.begin(), v.end());  // 0+1+2+3 = 6
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">*需要类型支持 operator+ 和默认构造
</span></span><span class="line"><span class="cl">vector&lt;string&gt; strs{&#34;a&#34;, &#34;b&#34;, &#34;c&#34;};
</span></span><span class="line"><span class="cl">string concat = reduce(strs.begin(), strs.end());  // &#34;&#34;+&#34;a&#34;+&#34;b&#34;+&#34;c&#34; = &#34;abc&#34;
</span></span></code></pre></div><h3 id="count_if-函数">
<a class="header-anchor" href="#count_if-%e5%87%bd%e6%95%b0"></a>
count_if() 函数
</h3><ul>
<li><code>std::count_if</code>是 C++ 标准库中的一个算法函数，用于<strong>统计满足特定条件的元素个数</strong>。它定义在 <code>&lt;algorithm&gt;</code>头文件中，是 STL 算法的重要组成部分。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">函数原型：
</span></span><span class="line"><span class="cl">template&lt; class InputIt, class UnaryPredicate &gt;
</span></span><span class="line"><span class="cl">typename iterator_traits&lt;InputIt&gt;::difference_type
</span></span><span class="line"><span class="cl">    count_if( InputIt first, InputIt last, UnaryPredicate p );
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">参数说明：
</span></span><span class="line"><span class="cl">	1. first, last: 输入范围的迭代器（前闭后开区间）
</span></span><span class="line"><span class="cl">	2. p: 一元谓词（返回 bool的可调用对象），用于测试元素是否满足条件
</span></span><span class="line"><span class="cl">返回值：
</span></span><span class="line"><span class="cl">	返回满足谓词条件的元素数量（类型为 difference_type，通常是 ptrdiff_t）
</span></span></code></pre></div><ul>
<li>用法举例：</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"> // 统计偶数个数
</span></span><span class="line"><span class="cl">    int even_count = std::count_if(nums.begin(), nums.end(), 
</span></span><span class="line"><span class="cl">        [](int n) { return n % 2 == 0; });
</span></span></code></pre></div><h2 id="c98">
<a class="header-anchor" href="#c98"></a>
C++98
</h2><h3 id="accumulate">
<a class="header-anchor" href="#accumulate"></a>
accumulate
</h3><ul>
<li><code>std::accumulate</code>是 C++ <strong>标准库</strong>中的算法函数，属于 <code>&lt;numeric&gt;</code>头文件，用于对序列中的元素进行累积计算（如求和、求积等）。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;numeric&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 形式1：使用默认加法操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">T</span> <span class="nf">accumulate</span><span class="p">(</span><span class="n">InputIt</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIt</span> <span class="n">last</span><span class="p">,</span> <span class="n">T</span> <span class="n">init</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 形式2：使用自定义二元操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">T</span> <span class="nf">accumulate</span><span class="p">(</span><span class="n">InputIt</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIt</span> <span class="n">last</span><span class="p">,</span> <span class="n">T</span> <span class="n">init</span><span class="p">,</span> <span class="n">BinaryOp</span> <span class="n">op</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">参数：</span>
</span></span><span class="line"><span class="cl"><span class="mf">1.</span> <span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="err">：输入范围的迭代器。</span>
</span></span><span class="line"><span class="cl"><span class="mf">2.</span> <span class="n">init</span><span class="err">：初始累积值（类型</span> <span class="n">T必须兼容操作结果</span><span class="err">）。</span>
</span></span><span class="line"><span class="cl"><span class="mf">3.</span> <span class="n">op</span><span class="err">：二元操作函数（可选，默认为</span> <span class="n">std</span><span class="o">::</span><span class="n">plus</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">()</span><span class="err">）。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">nums</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl"><span class="c1">// 求和，初始值为0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">nums</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 结果：0 + 1 + 2 + 3 + 4 + 5 = 15
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl"><span class="c1">// 求乘积，初始值为1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">product</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">nums</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">1</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">    <span class="p">[](</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 结果：1 * 1 * 2 * 3 * 4 * 5 = 120
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl"><span class="err">字符串连接</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">words</span><span class="p">{</span><span class="s">&#34;Hello&#34;</span><span class="p">,</span> <span class="s">&#34; &#34;</span><span class="p">,</span> <span class="s">&#34;World&#34;</span><span class="p">,</span> <span class="s">&#34;!&#34;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 字符串连接，初始值为空字符串
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">sentence</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 结果：&#34;&#34; + &#34;Hello&#34; + &#34; &#34; + &#34;World&#34; + &#34;!&#34; = &#34;Hello World!&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl"><span class="err">自定义操作</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 计算向量中元素的平方和
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">sum_of_squares</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">nums</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">[](</span><span class="kt">int</span> <span class="n">acc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 结果：0 + 1² + 2² + 3² + 4² + 5² = 55
</span></span></span></code></pre></div><h2 id="c20">
<a class="header-anchor" href="#c20"></a>
C++20
</h2><h3 id="erase-和-erase_if">
<a class="header-anchor" href="#erase-%e5%92%8c-erase_if"></a>
erase() 和 erase_if()
</h3><ul>
<li>std::erase() 和 std::erase_if() 是 <code>C++20</code>引入的两个新函数，用于简化从容器中删除元素的操作。它们提供了一种更安全、更简洁的方式来删除满足特定条件的元素，而无需手动处理迭代器或使用 erase-remove 惯用法</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// 移除所有值为2的元素
</span></span><span class="line"><span class="cl">    auto count = std::erase(nums, 2);  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 移除单个元素(通过迭代器)
</span></span><span class="line"><span class="cl">vec.erase(vec.begin() + 2); // 移除第三个元素(3)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 移除一个范围内的元素
</span></span><span class="line"><span class="cl">vec.erase(vec.begin(), vec.begin() + 2); // 移除前两个元素
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> // 移除所有偶数
</span></span><span class="line"><span class="cl">    auto count = std::erase_if(nums, [](int n) { return n % 2 == 0; });
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">// 通过键值移除元素
</span></span><span class="line"><span class="cl">set.erase(3); // 移除值为3的元素
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 通过迭代器移除
</span></span><span class="line"><span class="cl">set.erase(s.begin()); // 移除第一个元素
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">特点：
</span></span><span class="line"><span class="cl">1.直接操作容器，不需要手动指定迭代器范围
</span></span><span class="line"><span class="cl">2.返回被移除的元素数量
</span></span><span class="line"><span class="cl">3.保持容器中剩余元素的相对顺序(序列容器)
</span></span><span class="line"><span class="cl">4.谓词可以是任何可调用对象(函数指针、lambda、函数对象等)
</span></span></code></pre></div><hr>
<h3 id="stdformat函数-和-----b-">
<a class="header-anchor" href="#stdformat%e5%87%bd%e6%95%b0-%e5%92%8c-----b-"></a>
<code>std::format()</code>函数 和  <code> { : b }</code>
</h3><ol>
<li><code>std::format</code>是 C++20 新增的 <strong>字符串格式化库</strong>，类似于 Python 的 <code>str.format()</code>或 C 的 <code>printf</code>，但更安全、更现代化。</li>
</ol>
<p>基本语法：</p>
        
        <hr><p>本文2025-08-10首发于<a href='//localhost:1313/'></a>，最后修改于2025-08-10</p>]]>
      </description>
      
        <category>笔记</category>
      
    </item>
    
    

    <item>
      <title>linux学习过程心得体会</title>
      <link>//localhost:1313/post/linux/</link>
      <pubDate>Sun, 10 Aug 2025 22:02:00 -0800</pubDate>
      <author>2267593025@qq.com (the_last_kid)</author>
      <guid>//localhost:1313/post/linux/</guid>
      <description>
        <![CDATA[<h1>linux学习过程心得体会</h1><p>作者：the_last_kid（2267593025@qq.com）</p>
        
          <h1 id="linux-学习笔记">
<a class="header-anchor" href="#linux-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"></a>
LINUX 学习笔记
</h1><h2 id="linux命令基础格式">
<a class="header-anchor" href="#linux%e5%91%bd%e4%bb%a4%e5%9f%ba%e7%a1%80%e6%a0%bc%e5%bc%8f"></a>
Linux命令基础格式
</h2><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">command [-options] [parameter]
</span></span></code></pre></div><ul>
<li>command：命令本身</li>
<li>-options：[可选，非必填]，命令的一些选项，可以通过选项控制命令的行为细节</li>
<li>parameter：[可选，非必填]，命令的参数，多数用于命令的指向目标</li>
</ul>
<h3 id="ls命令">
<a class="header-anchor" href="#ls%e5%91%bd%e4%bb%a4"></a>
ls命令
</h3><ol>
<li>ls 命令的参数作用，可以指定要查看的文件夹（目录）的内容，如果不给定参数，默认当前工作目录的内容</li>
<li>ls 的命令选项：
<ul>
<li>-a：可以展示出隐藏的内容
<ul>
<li>以<code>.</code>开头的文件或文件夹默认被隐藏，需要-a才能显示出来</li>
</ul>
</li>
<li>-l：以列表的形式展示内容，并展示更多细节</li>
<li>-h：需要和-l 选项搭配使用，以更加人性化的方式显示文件的大小单位</li>
</ul>
</li>
<li>命令的选项是可以组合使用的，比如：<code>ls -lah = ls -a -l -h</code></li>
</ol>
<h3 id="cd命令">
<a class="header-anchor" href="#cd%e5%91%bd%e4%bb%a4"></a>
cd命令
</h3><ol>
<li>
<p>cd命令的作用</p>
        
        <hr><p>本文2025-08-10首发于<a href='//localhost:1313/'></a>，最后修改于2025-08-10</p>]]>
      </description>
      
        <category>笔记</category>
      
    </item>
    
    

    <item>
      <title>真正意义上的第一篇博客</title>
      <link>//localhost:1313/post/firstblog/</link>
      <pubDate>Sat, 09 Aug 2025 11:32:00 -0800</pubDate>
      <author>2267593025@qq.com (the_last_kid)</author>
      <guid>//localhost:1313/post/firstblog/</guid>
      <description>
        <![CDATA[<h1>真正意义上的第一篇博客</h1><p>作者：the_last_kid（2267593025@qq.com）</p>
        
          <h1 id="正式开始小白乐的博客生涯">
<a class="header-anchor" href="#%e6%ad%a3%e5%bc%8f%e5%bc%80%e5%a7%8b%e5%b0%8f%e7%99%bd%e4%b9%90%e7%9a%84%e5%8d%9a%e5%ae%a2%e7%94%9f%e6%b6%af"></a>
正式开始小白乐的博客生涯
</h1><h2 id="先记录一下搭建博客的过程">
<a class="header-anchor" href="#%e5%85%88%e8%ae%b0%e5%bd%95%e4%b8%80%e4%b8%8b%e6%90%ad%e5%bb%ba%e5%8d%9a%e5%ae%a2%e7%9a%84%e8%bf%87%e7%a8%8b"></a>
先记录一下搭建博客的过程！
</h2><ol>
<li>过程真的很繁琐，网上的视频教程不是很详细，虽然但是，仅凭我一个人真的搞不定，所以在淘宝上花rmb请人帮我实操了，该说不说，这位大哥确实很顶，态度非常之诚恳，技术相当之过硬，话术非常之高端（听起来很专业~），对于我的每一个请求，都相当之耐心，就我觉得太麻烦不好实现的功能，这位哥还是很坚持的帮助我实现‘愿望’，虽然但是，可能不是很完美的还原功能，但是大哥的心意和精神，相当的值得肯定，牛逼！佬！然后就是一些细枝末节的外观美化和小tips，这些就交给小白乐自己弄吧，确实不好意思再麻烦大哥了，总共就给人家100软妹币，不仅给我讲解操作，还直接远程操控我电脑帮我弄，还给我解决问题，前前后后大概四五个小时，他人真的我哭死。感觉对面也就是大我五六岁（最多）的样子，但是看看人家，再看看我，感觉我是个飞舞，啥都不会~还是计算机专业的学生，这&hellip;&hellip;</li>
<li>但是，还是搞定了，不管过程怎么样，结果是好的就行，嘻嘻！</li>
</ol>
<h2 id="再记录一下搭建博客中遇到的一些问题">
<a class="header-anchor" href="#%e5%86%8d%e8%ae%b0%e5%bd%95%e4%b8%80%e4%b8%8b%e6%90%ad%e5%bb%ba%e5%8d%9a%e5%ae%a2%e4%b8%ad%e9%81%87%e5%88%b0%e7%9a%84%e4%b8%80%e4%ba%9b%e9%97%ae%e9%a2%98"></a>
再记录一下搭建博客中遇到的一些问题
</h2><ol>
<li>
<p>首先就是心仪的这个二次元的主题跟视频里的文件结构不一样，所以憨憨乐找不到对应的文件（这就是不看人家readme的下场），所以迫不得已才寻求help，但是都是小问题</p>
        
        <hr><p>本文2025-08-09首发于<a href='//localhost:1313/'></a>，最后修改于2025-08-09</p>]]>
      </description>
      
        <category>Meaningful</category>
      
    </item>
    
  </channel>
</rss>
